from datetime import datetime
import sys
import re
import requests
import random
import json
import os
import asyncio


from decouple import config
from discord import app_commands
import discord
from discord.app_commands import Command, Group, command
from discord.ext import commands, tasks
from discord.ext.commands.errors import MissingRequiredArgument, CommandNotFound



intents = discord.Intents.default()
intents.message_content = True  # Necess√°rio para ler mensagens

bot = commands.Bot(command_prefix="/", intents=intents, help_command=None)
tree = bot.tree  # Objeto para registrar Slash Commands

# ------------------------------------------ BOT EVENTS ------------------------------------------ #

palavras_regex = re.compile(r"\b(merda|porra|caralho|bct|prr|krlh|puta|puto|fdp|filho da puta|desgra√ßado|bosta|vagabundo|vagabunda|arrombado|cuz√£o|cuzinha|buceta|babaca|ot√°rio|otaria|escroto|escrota|viado|veado|boiola|piranha|cacete|rola|pau no cu|pau|corno|corna|retardado|mongol|jumento|anta|imbecil|idiota|burro|burra)\b", re.IGNORECASE)

@bot.event
async def on_message(message):
    if message.author == bot.user:
        return

    if palavras_regex.search(message.content):
        await message.channel.send(f"{message.author.mention}, evite linguagem ofensiva.")
        await message.delete()

    await bot.process_commands(message)

@bot.event
async def on_ready():
    print(f"Estou pronto! Estou conectado como {bot.user}")

    # Canal de status
    canal = bot.get_channel(1367650512492695572)
    if canal:
        embed = discord.Embed(
            title="ü§ñ Bot Oliveira Online!",
            description="O bot foi iniciado com sucesso e est√° pronto para uso!",
            color=0x00ff00
        )
        embed.set_thumbnail(url=bot.user.display_avatar.url)
        embed.set_footer(text="Status atualizado automaticamente.")
        await canal.send(embed=embed)

    # üîß Modo de desenvolvimento (True = sync s√≥ em servidor de testes)
    MODO_DEV = True
    SERVIDOR_DE_TESTE = 1195507908075597844

    try:
        if MODO_DEV:
            synced = await bot.tree.sync(guild=discord.Object(id=SERVIDOR_DE_TESTE))
            print(f"‚úÖ {len(synced)} comando(s) sincronizado(s) no servidor de testes.")
        else:
            synced = await bot.tree.sync()
            print(f"üåç {len(synced)} comando(s) sincronizado(s) globalmente.")
    except Exception as e:
        print(f"‚ùå Erro ao sincronizar comandos: {e}")

    # Inicia tarefas de background
    current_time.start()

@bot.event
async def on_command_error(ctx, error):
    if isinstance(error, MissingRequiredArgument):
        await ctx.send("Por favor, escreva o comando corretamente, digite !help para ver os comandos e suas funcionalidades!")
    elif isinstance(error, CommandNotFound):
        await ctx.send("Por favor, escreva o comando corretamente, digite !help para ver os comandos e suas funcionalidades!")
    else:
        raise error

# ------------------------------------------ BOT COMANDS ------------------------------------------ #

# Help
@tree.command(name="help", description="Mostra to       dos os comandos dispon√≠veis")
async def help_slash(interaction: discord.Interaction):
    try:
        await interaction.response.defer()  # Defere a resposta, indicando que o bot est√° processando o comando
        
        embed = discord.Embed(title="üìò Lista de Comandos", color=0x00ff00)
        
        # Obtemos todos os comandos registrados de forma correta
        for command in bot.tree.get_commands():
            embed.add_field(name=f"/{command.name}", value=command.description or "Sem descri√ß√£o", inline=False)
        
        await interaction.followup.send(embed=embed)
    except Exception as e:
        await interaction.followup.send(f"‚ö†Ô∏è Ocorreu um erro ao tentar listar os comandos: {e}")


# QAP
@tree.command(name="qap", description="Testa se o bot est√° online (Ping)")
async def qap_slash(interaction: discord.Interaction):
    await interaction.response.send_message("QAP Comando, Prossiga!!")

STEAM_FILE = "steam_ids.json"
steam_data_path = STEAM_FILE

def load_steam_data():
    if not os.path.exists(STEAM_FILE):
        return {}
    with open(STEAM_FILE, "r") as f:
        return json.load(f)
    
def salvar_steam_data(caminho, dados):
    with open(caminho, "w") as f:
        json.dump(dados, f, indent=4)

class Steam(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @app_commands.command(name="linksteam", description="Vincule seu Steam ID ao seu Discord.")
    @app_commands.describe(steam_id="Seu Steam ID num√©rico")
    async def linksteam(self, interaction: discord.Interaction, steam_id: str):
        steam_data = load_steam_data()
        user_id = str(interaction.user.id)

        if steam_id in steam_data.values():
            await interaction.response.send_message("‚ùå Esse SteamID j√° est√° vinculado a outro usu√°rio.", ephemeral=True)
            return

        if user_id in steam_data:
            await interaction.response.send_message(
                f"‚ùå Voc√™ j√° vinculou a Steam `{steam_data[user_id]}`.\nEntre em contato com um administrador para alterar.",
                ephemeral=True
            )
            return

        steam_data[user_id] = steam_id
        salvar_steam_data(steam_data_path, steam_data)

        await interaction.response.send_message(f"‚úÖ SteamID `{steam_id}` vinculado com sucesso!", ephemeral=True)

    @app_commands.command(name="versteamid", description="Veja o Steam ID que voc√™ vinculou.")
    async def versteamid(self, interaction: discord.Interaction):
        steam_data = load_steam_data()
        user_id = str(interaction.user.id)

        if user_id in steam_data:
            steam_id = steam_data[user_id]
            await interaction.response.send_message(f"üîó Seu SteamID vinculado √©: `{steam_id}`", ephemeral=True)
        else:
            await interaction.response.send_message("‚ùå Voc√™ ainda n√£o vinculou nenhum SteamID.", ephemeral=True)
    
    @app_commands.command(name="resetsteam", description="Desvincula seu Steam ID do Discord.")
    async def desvincularsteam(self, interaction: discord.Interaction):
        steam_data = load_steam_data()
        user_id = str(interaction.user.id)

        if user_id not in steam_data:
            await interaction.response.send_message("‚ùå Voc√™ n√£o possui nenhum SteamID vinculado.", ephemeral=True)
            return

        steam_id_removido = steam_data.pop(user_id)
        salvar_steam_data(steam_data_path, steam_data)

        await interaction.response.send_message(f"‚úÖ SteamID `{steam_id_removido}` foi desvinculado com sucesso.", ephemeral=True)

async def setup(bot: commands.Bot):
    await bot.add_cog(Steam(bot))

# Comando Slash para exibir os jogos mais jogados (slash)
@bot.tree.command(name="timeplayed", description="Exibe os principais jogos da sua biblioteca por tempo jogado")
async def timeplayed_slash(interaction: discord.Interaction):
    await interaction.response.defer()
    try:
        steam_data = load_steam_data()

        # Recuperar Steam ID do usu√°rio
        steam_id = None
        for key, value in steam_data.items():
            if value == str(interaction.user.id):
                steam_id = key
                break

        if not steam_id:
            await interaction.followup.send("Voc√™ n√£o vinculou seu Steam ID ainda. Use o comando `/linksteam`.")
            return

        # Buscar dados da Steam
        API_KEY = config("API_KEY")
        url = "https://api.steampowered.com/IPlayerService/GetOwnedGames/v1/"
        params = {
            "key": API_KEY,
            "steamid": steam_id,
            "include_appinfo": True,
            "include_played_free_games": True
        }

        response = requests.get(url, params=params)
        data = response.json()

        if "response" in data and "games" in data["response"]:
            jogos = data["response"]["games"]

            # Filtrar e calcular o tempo total de horas jogadas
            ranking = [
                {
                    "nome": jogo["name"],
                    "horas": round(jogo["playtime_forever"] / 60, 2)  # Convertendo minutos para horas
                }
                for jogo in jogos
                if jogo["playtime_forever"] > 0  # Somente jogos com tempo jogado
            ]

            # Ordenar os jogos por horas jogadas em ordem decrescente
            ranking.sort(key=lambda x: x["horas"], reverse=True)

            # Pegando os 10 jogos mais jogados
            top10 = ranking[:10]

            # Calculando o total de horas jogadas
            total_hours = sum(jogo["horas"] for jogo in top10)

            # Criando a resposta com os jogos
            embed = discord.Embed(
                title="üéÆ Seus Jogos Mais Jogados üéÆ",
                description=f"{interaction.user.mention}, Aqui est√£o seus jogos mais jogados na Steam.",
                color=0x00FF00
            )

            embed.add_field(name="Total de Horas Jogadas", value=f"{total_hours} horas", inline=False)

            for i, jogo in enumerate(top10, start=1):
                embed.add_field(name=f"{i}. {jogo['nome']}", value=f"{jogo['horas']} horas", inline=True)

            await interaction.followup.send(embed=embed)
        else:
            await interaction.followup.send("Nenhum jogo encontrado ou perfil privado.")

    except Exception as e:
        await interaction.followup.send(f"‚ö†Ô∏è Erro ao buscar dados: {e}")

# Comando de rein√≠cio
@tree.command(name="restart", description="Reinicia o bot")
async def restart(interaction: discord.Interaction):
    if interaction.user.guild_permissions.administrator:
        await interaction.response.send_message("Reiniciando o bot... üöÄ")
        await asyncio.sleep(2)  # Pequena espera antes de encerrar
        sys.exit("Bot reiniciado!")
    else:
        await interaction.response.send_message("Voc√™ n√£o tem permiss√£o para reiniciar o bot.") 


frases_motivacionais = [
    ("A persist√™ncia √© o caminho do √™xito.", "Charles Chaplin"),
    ("S√≥ se pode alcan√ßar um grande √™xito quando nos mantemos fi√©is a n√≥s mesmos.", "Friedrich Nietzsche"),
    ("Tente mover o mundo ‚Äì o primeiro passo ser√° mover a si mesmo.", "Plat√£o"),
    ("A vantagem de ter p√©ssima mem√≥ria √© divertir-se muitas vezes com as mesmas coisas boas como se fosse a primeira vez.", "Friedrich Nietzsche"),
    ("O sucesso nasce do querer, da determina√ß√£o e persist√™ncia em se chegar a um objetivo.", "Jos√© de Alencar"),
    ("A confian√ßa √© uma mulher ingrata, Que te beija e te abra√ßa, te rouba e te mata.", "Racionais MC's"),
    ("De todos os animais selvagens, o homem jovem √© o mais dif√≠cil de domar.", "Plat√£o"),
    ("Deve-se temer a velhice, porque ela nunca vem s√≥. Bengalas s√£o provas de idade e n√£o de prud√™ncia.", "Plat√£o"),
    ("√â mais f√°cil lidar com uma m√° consci√™ncia do que com uma m√° reputa√ß√£o.", "Friedrich Nietzsche"),
    ("O que me preocupa n√£o √© o grito dos maus. √â o sil√™ncio dos bons.", "Martin Luther King Jr."),
    ("N√£o espere por uma crise para descobrir o que √© importante em sua vida.", "Plat√£o"),
    ("A coragem √© a primeira das qualidades humanas porque garante todas as outras.", "Arist√≥teles"),
    ("A maior gl√≥ria em viver n√£o est√° em nunca cair, mas em nos levantar cada vez que ca√≠mos.", "Nelson Mandela"),
    ("Quem olha para fora, sonha; quem olha para dentro, desperta.", "Carl Jung"),
    ("A mente que se abre a uma nova ideia jamais voltar√° ao seu tamanho original.", "Albert Einstein"),
    ("Nada √© pequeno quando feito com amor.", "C√≠cero"),
    ("A felicidade n√£o est√° em fazer o que se quer, mas em querer o que se faz.", "Jean-Paul Sartre"),
    ("Se queres ser feliz amanh√£, tenta hoje mesmo.", "Liang Tzu"),
    ("√â durante os momentos mais sombrios que devemos focar para ver a luz.", "Arist√≥teles"),
    ("A vida √© 10% o que acontece com voc√™ e 90% como voc√™ reage a isso.", "Charles Swindoll")
]

emojis = [
    ("üòÅ"),
    ("‚úåÔ∏è"),
    ("ü•∂"),
    ("‚õÖ"),
    ("üåπ"),
    ("‚òÄÔ∏è"),
    ("üí∞"),
    ("üçé"),
    ("üññ"),
    ("üî•"),
    ("üéØ"),
    ("üéâ"),
    ("ü§ñ"),
    ("üß†"),
    ("üöÄ"),
    ("üêç"),
    ("üõ°Ô∏è"),
    ("üìö")
]

@tasks.loop(hours=24)
async def current_time():
    channel = bot.get_channel(1367650512492695572)

    frase, autor = random.choice(frases_motivacionais)
    emoji = random.choice(emojis)
    mensagem = f"{emoji} *\"{frase}\"* ‚Äî **{autor}**"

    if channel:
        await channel.send(mensagem)

TOKEN = config("TOKEN")
bot.run(TOKEN)
